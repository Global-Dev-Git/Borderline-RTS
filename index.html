<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Borderline RTS</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #111;
        overflow: hidden;
        -webkit-user-select: none;
        user-select: none;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        color: #eee;
      }
      #ui {
        position: absolute;
        top: 8px;
        left: 8px;
        display: flex;
        gap: 8px;
        z-index: 10;
        pointer-events: none;
      }
      #ui .panel {
        pointer-events: auto;
        background: rgba(0,0,0,0.45);
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.15);
        -webkit-backdrop-filter: blur(2px);
        backdrop-filter: blur(2px);
      }
      #ui button {
        background: #1f6feb;
        color: white;
        border: none;
        padding: 6px 10px;
        border-radius: 6px;
        cursor: pointer;
      }
      #overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); z-index: 20; text-align: center; }
      #overlay.show { display: flex; }
      #overlay .card { background: rgba(0,0,0,0.75); border: 1px solid rgba(255,255,255,0.15); padding: 18px 24px; border-radius: 10px; }
      #overlay h1 { margin: 0 0 6px 0; font-size: 28px; }
      #overlay p { margin: 6px 0 14px 0; color: #ccc; }
      #startOverlay { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 30; background: rgba(0,0,0,0.55); }
      #startOverlay.hidden { display: none; }
      #startOverlay .card { background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.15); padding: 22px 28px; border-radius: 12px; text-align: center; }
      #countdown { font-size: 42px; margin-top: 8px; letter-spacing: 1px; }
      .diffRow { margin:8px 0; }
      .ml10 { margin-left:10px; }
      /* Editor UI tweaks */
      #ui select, #ui input[type="range"] { margin-left: 6px; }
      #ui label { margin-right: 8px; }
      #ui .group { margin-top: 6px; }
      #ui .danger { background:#8b2a2a; }
      #ui .ghost { background:#333; }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div id="ui">
      <div class="panel" id="hudPanel"><div id="hudText">Loading…</div></div>
      <div class="panel"><button id="restartBtn" title="Restart (R)">Restart</button></div>
      <div class="panel" title="Tips">LMB drag to select • Right-click to move • A=Select all • Space=Pause</div>
      <div class="panel" id="editorPanel">
        <button id="editorToggle" title="Toggle editor (E)">Editor</button>
        <button id="editorPlayBtn" class="ghost" title="Open Start to Play">Play</button>
        <button id="editorSaveBtn" title="Save scenario to file">Save</button>
        <button id="editorLoadBtn" title="Load scenario from file">Load</button>
        <input id="editorFileInput" type="file" accept=".json" style="display:none" />
      </div>
      <div class="panel" id="editorControls" style="display:none; max-width: 58vw;">
        <div class="group">
          <strong>Tool</strong>:
          <label><input type="radio" name="tool" value="terrain" checked> Terrain</label>
          <label><input type="radio" name="tool" value="owner"> Owner</label>
          <label><input type="radio" name="tool" value="city"> City</label>
          <label><input type="radio" name="tool" value="unit"> Unit</label>
          <label><input type="radio" name="tool" value="eraser"> Eraser</label>
        </div>
        <div class="group" id="toolTerrain">
          <strong>Terrain</strong>:
          <select id="terrainSelect"></select>
          <label class="ml10">Brush <input id="brushSize" type="range" min="1" max="8" value="2"></label>
        </div>
        <div class="group" id="toolOwner" style="display:none;">
          <strong>Owner</strong>:
          <label><input type="radio" name="ownerSide" value="blue" checked> Blue</label>
          <label><input type="radio" name="ownerSide" value="red"> Red</label>
          <label class="ml10">Brush <input id="ownerBrushSize" type="range" min="1" max="8" value="2"></label>
        </div>
        <div class="group" id="toolCity" style="display:none;">
          <strong>City</strong>:
          <label><input type="radio" name="citySide" value="blue" checked> Blue</label>
          <label><input type="radio" name="citySide" value="red"> Red</label>
          <label class="ml10"><input type="checkbox" id="cityIsCapital"> Capital</label>
          <span class="ml10" style="color:#ccc">Left-click to place, Right-click to remove</span>
        </div>
        <div class="group" id="toolUnit" style="display:none;">
          <strong>Unit</strong>:
          <label><input type="radio" name="unitSide" value="blue" checked> Blue</label>
          <label><input type="radio" name="unitSide" value="red"> Red</label>
          <label class="ml10"><input type="checkbox" id="unitIsTank"> Tank</label>
          <span class="ml10" style="color:#ccc">Left-click to place, Right-click to remove</span>
        </div>
        <div class="group">
          <button id="editorGenNoiseBtn" class="ghost" title="Regenerate map from noise">New Random Map</button>
          <button id="editorClearBtn" class="danger" title="Set all to plains and reset ownership">Clear</button>
        </div>
      </div>
    </div>
    <div id="overlay"><div class="card"><h1 id="resultTitle"></h1><p id="resultSubtitle"></p><button id="playAgain">Play again</button></div></div>
    <div id="startOverlay">
      <div class="card">
        <h1>Borderline RTS</h1>
        <p>Select difficulty, AI behavior, and speed.</p>
        <div class="diffRow">
          <label><input type="radio" name="diff" value="veryeasy"> Very Easy</label>
          <label class="ml10"><input type="radio" name="diff" value="slightlyeasy"> Slightly Easy</label>
          <label class="ml10"><input type="radio" name="diff" value="easy"> Easy</label>
          <label class="ml10"><input type="radio" name="diff" value="normal" checked> Normal</label>
          <label class="ml10"><input type="radio" name="diff" value="slightlyhard"> Slightly Hard</label>
          <label class="ml10"><input type="radio" name="diff" value="hard"> Hard</label>
          <label class="ml10"><input type="radio" name="diff" value="veryhard"> Very Hard</label>
        </div>
        <div class="diffRow">
          <label><input type="radio" name="speed" value="veryslow"> Speed: Very Slow</label>
          <label class="ml10"><input type="radio" name="speed" value="slow"> Slow</label>
          <label class="ml10"><input type="radio" name="speed" value="default" checked> Default (Slow)</label>
          <label class="ml10"><input type="radio" name="speed" value="normal"> Normal</label>
          <label class="ml10"><input type="radio" name="speed" value="slightlyfast"> Slightly Fast</label>
          <label class="ml10"><input type="radio" name="speed" value="fast"> Fast</label>
          <label class="ml10"><input type="radio" name="speed" value="veryfast"> Very Fast</label>
        </div>
        <div class="diffRow">
          <label><input type="radio" name="agg" value="veryaggressive"> Very Aggressive</label>
          <label class="ml10"><input type="radio" name="agg" value="aggressive"> Aggressive</label>
          <label class="ml10"><input type="radio" name="agg" value="slightlyaggressive"> Slightly Aggressive</label>
          <label class="ml10"><input type="radio" name="agg" value="balanced" checked> Balanced/Normal</label>
          <label class="ml10"><input type="radio" name="agg" value="slightlydefensive"> Slightly Defensive</label>
          <label class="ml10"><input type="radio" name="agg" value="defensive"> Defensive</label>
          <label class="ml10"><input type="radio" name="agg" value="verydefensive"> Very Defensive</label>
        </div>
        <div class="diffRow">
          <label><input type="checkbox" id="spectateChk"> Spectate (AI vs AI)</label>
        </div>
        <div id="spectateOptions" class="diffRow" style="display:none; text-align:left;">
          <div style="margin-bottom:6px;">Blue AI:</div>
          <div class="ml10">
            <label><input type="radio" name="diffBlue" value="veryeasy"> Very Easy</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="slightlyeasy"> Slightly Easy</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="easy"> Easy</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="normal" checked> Normal</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="slightlyhard"> Slightly Hard</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="hard"> Hard</label>
            <label class="ml10"><input type="radio" name="diffBlue" value="veryhard"> Very Hard</label>
          </div>
          <div class="ml10" style="margin-top:6px;">
            <label><input type="radio" name="aggBlue" value="veryaggressive"> Very Aggressive</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="aggressive"> Aggressive</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="slightlyaggressive"> Slightly Aggressive</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="balanced" checked> Balanced/Normal</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="slightlydefensive"> Slightly Defensive</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="defensive"> Defensive</label>
            <label class="ml10"><input type="radio" name="aggBlue" value="verydefensive"> Very Defensive</label>
          </div>
        </div>
        <button id="startBtn">Start</button>
        <button id="openEditorBtn" class="ml10">Open Editor</button>
        <div id="countdown"></div>
      </div>
    </div>

    <script>
      const CONFIG = {
        tileSize: 6,
        mapCols: 128,
        mapRows: 72,
        baseUnit: { radius: 10, baseSpeed: 48, hp: 120, dps: 14 },
        tankUnit: { radius: 12, baseSpeed: 30, hp: 260, dps: 28 },
        tankChance: 0.25,
        capturePerSecond: 22,
        tileControlThreshold: 60,
        cityCapturePerSecond: 16,
        cityCaptureThreshold: 120,
        selectionColor: 'rgba(255,255,255,0.35)',
        team: { blue: { color: '#3ba1ff', outline: '#0c3a66' }, red: { color: '#ff4d4d', outline: '#5a0e0e' } },
        terrain: {
          // Main terrains
          plains:   { color: '#90a567', move: 1.0, damageTakenMultiplier: 1.0,  healPerSecond: 0.0,  navalMove: Infinity },
          desert:   { color: '#e0c164', move: 1.2, damageTakenMultiplier: 1.1,  healPerSecond: -0.5, navalMove: Infinity },
          jungle:   { color: '#1b582a', move: 2.5, damageTakenMultiplier: 0.75,  healPerSecond: 3.0,  navalMove: Infinity },
          tundra:   { color: '#a7c6d9', move: 1.1, damageTakenMultiplier: 0.95,  healPerSecond: 0.0,  navalMove: Infinity },
          // Secondary terrains
          forest:   { color: '#2b6a39', move: 2.0, damageTakenMultiplier: 0.8,   healPerSecond: 2.0,  navalMove: Infinity },
          savannah: { color: '#cdbb6e', move: 1.3, damageTakenMultiplier: 1.0,   healPerSecond: 0.0,  navalMove: Infinity },
          hills:    { color: '#caa17c', move: 3.0, damageTakenMultiplier: 0.95,  healPerSecond: 0.0,  navalMove: Infinity },
          mountain: { color: '#6b6b6b', move: 5.0, damageTakenMultiplier: 0.7,  healPerSecond: 0.0, navalMove: Infinity },
          river:    { color: '#2a76db', move: 5.0, damageTakenMultiplier: 1.2,   healPerSecond: -2.0, navalMove: 1.0 },
          lake:     { color: '#1f5fb7', move: Infinity, damageTakenMultiplier: 1.2, healPerSecond: -2.0, navalMove: 1.2 },
          ocean:    { color: '#174b9e', move: Infinity, damageTakenMultiplier: 1.2, healPerSecond: -2.0, navalMove: 1.5 },
          water:    { color: '#3ab0c2', move: Infinity, damageTakenMultiplier: 1.2,  healPerSecond: -2.0, navalMove: 1.1 },
          snow:     { color: '#e7f4ff', move: 1.9, damageTakenMultiplier: 0.9,   healPerSecond: 0.5,  navalMove: Infinity },
        },
        difficultyPresets: {
          veryeasy:    { spawnIntervalMult: 2.4, aiDamageMult: 0.55, aiSpeedMult: 0.85, aiHpMult: 0.75, aiPlanFactor: 1.35 },
          slightlyeasy:{ spawnIntervalMult: 1.8, aiDamageMult: 0.75, aiSpeedMult: 0.93, aiHpMult: 0.9,  aiPlanFactor: 1.2 },
          easy:        { spawnIntervalMult: 1.5, aiDamageMult: 0.85, aiSpeedMult: 0.95, aiHpMult: 0.95, aiPlanFactor: 1.1 },
          normal:      { spawnIntervalMult: 1.0, aiDamageMult: 1.0,  aiSpeedMult: 1.0,  aiHpMult: 1.0,  aiPlanFactor: 1.0 },
          slightlyhard:{ spawnIntervalMult: 0.85,aiDamageMult: 1.15, aiSpeedMult: 1.05, aiHpMult: 1.08, aiPlanFactor: 0.92 },
          hard:        { spawnIntervalMult: 0.7, aiDamageMult: 1.3,  aiSpeedMult: 1.12, aiHpMult: 1.18, aiPlanFactor: 0.85 },
          veryhard:    { spawnIntervalMult: 0.5, aiDamageMult: 1.5,  aiSpeedMult: 1.2,  aiHpMult: 1.3,  aiPlanFactor: 0.75 }
        },
        aggressionPresets: {
          veryaggressive:   { defendWeight: 0.4, capFocus: 1.4, groupSizeMult: 1.2 },
          aggressive:       { defendWeight: 0.6, capFocus: 1.25, groupSizeMult: 1.1 },
          slightlyaggressive:{ defendWeight:0.8, capFocus: 1.1,  groupSizeMult: 1.05 },
          balanced:        { defendWeight: 1.0, capFocus: 1.0,  groupSizeMult: 1.0 },
          slightlydefensive:{ defendWeight:1.2, capFocus: 0.95, groupSizeMult: 0.95 },
          defensive:       { defendWeight: 1.4, capFocus: 0.9,  groupSizeMult: 0.9 },
          verydefensive:   { defendWeight: 1.7, capFocus: 0.85, groupSizeMult: 0.85 }
        },
        borders: { color: '#0e0e1a', width: 3.5 },
        // Slower than last edit but still faster than original (30s/25s)
        spawn: { citySeconds: 28, capitalSeconds: 20 },
        ai: { planEverySeconds: 1, groupRadius: 80, defenseRadius: 160, garrisonSize: 3, attackGroupSize: 10 },
        frontline: { rowStep: 4, jitter: 6, unitsPerSidePerRow: 1 },
        controls: { retreatGrace: 2.0 },
        pathVis: { width: 2, color: 'rgba(255,255,255,0.8)', dash: [6,4] },
        engageRadius: 18,
        captureBlockRadius: 28,
        movementCaptureMultiplier: 18,
        minGapFactor: 2.0,
        captureBrushTiles: 2,
        encirclementCheckSeconds: 1.0,
        cityDamageMinMultiplier: 0.6,
        cityDamageFalloffPx: 1200,
        friendlyCrowdSlowPerUnit: 0.35,
          friendlyCrowdRadius: 14,
        formation: { advanceSpeed: 24, retargetPx: 22 },
        infantryWaterMove: 15.0,
        // New pacing controls
        defaultTimeScale: 0.6,
        speedPresets: {
          veryslow: 0.4,
          slow: 0.5,
          default: 0.6,
          normal: 1.0,
          slightlyfast: 1.25,
          fast: 1.5,
          veryfast: 2.0
        },
        combatPush: { maxPxPerSec: 28 }
      };

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hudText = document.getElementById('hudText');
      const overlay = document.getElementById('overlay');
      const resultTitle = document.getElementById('resultTitle');
      const resultSubtitle = document.getElementById('resultSubtitle');
      const playAgain = document.getElementById('playAgain');
      const restartBtn = document.getElementById('restartBtn');
      const startOverlay = document.getElementById('startOverlay');
      const startBtn = document.getElementById('startBtn');
      const countdownEl = document.getElementById('countdown');
      const editorPanel = document.getElementById('editorPanel');
      const editorControls = document.getElementById('editorControls');
      const editorToggle = document.getElementById('editorToggle');
      const editorPlayBtn = document.getElementById('editorPlayBtn');
      const editorSaveBtn = document.getElementById('editorSaveBtn');
      const editorLoadBtn = document.getElementById('editorLoadBtn');
      const editorFileInput = document.getElementById('editorFileInput');
      const terrainSelect = document.getElementById('terrainSelect');
      const brushSizeInput = document.getElementById('brushSize');
      const ownerBrushInput = document.getElementById('ownerBrushSize');
      const cityIsCapitalChk = document.getElementById('cityIsCapital');
      const unitIsTankChk = document.getElementById('unitIsTank');
      const editorGenNoiseBtn = document.getElementById('editorGenNoiseBtn');
      const editorClearBtn = document.getElementById('editorClearBtn');
      const openEditorBtn = document.getElementById('openEditorBtn');
      let editor = { mode:false, tool:'terrain', terrain:'plains', brush:2, owner:'blue', ownerBrush:2, city:{ side:'blue', capital:false }, unit:{ side:'blue', tank:false }, dragging:false, scenario:null };
      function updateUIVisibility(){ const ui=document.getElementById('ui'); if(!ui) return; ui.style.display = (editor && editor.mode) ? 'flex' : ((state && state.paused) ? 'flex' : 'none'); }
      function getSelectedDifficulty(){ const radios=document.querySelectorAll('input[name="diff"]'); for(const r of radios){ if(r.checked) return r.value; } return 'normal'; }
      function getSelectedAggression(){ const radios=document.querySelectorAll('input[name="agg"]'); for(const r of radios){ if(r.checked) return r.value; } return 'balanced'; }
      function getSelectedSpeed(){ const radios=document.querySelectorAll('input[name="speed"]'); for(const r of radios){ if(r.checked) return r.value; } return 'default'; }
      function getSpectate(){ const el=document.getElementById('spectateChk'); return !!(el && el.checked); }
      function getSelectedDifficultyBlue(){ const radios=document.querySelectorAll('input[name="diffBlue"]'); for(const r of radios){ if(r.checked) return r.value; } return 'normal'; }
      function getSelectedAggressionBlue(){ const radios=document.querySelectorAll('input[name="aggBlue"]'); for(const r of radios){ if(r.checked) return r.value; } return 'balanced'; }

      function resizeCanvasToWindow() {
        canvas.width = Math.floor(window.innerWidth);
        canvas.height = Math.floor(window.innerHeight);
        if(state && state.map){
          CONFIG.mapCols = state.map.cols;
          CONFIG.mapRows = state.map.rows;
        } else {
          CONFIG.mapCols = Math.max(80, Math.floor(canvas.width / CONFIG.tileSize));
          CONFIG.mapRows = Math.max(45, Math.floor(canvas.height / CONFIG.tileSize));
        }
        TILE_W = Math.floor(canvas.width / CONFIG.mapCols);
        TILE_H = Math.floor(canvas.height / CONFIG.mapRows);
        // Invalidate cached render layers on resize
        if (state) { state.terrainCanvas = null; state.ownerTintCanvas = null; state._borderSegments = null; }
      }
      window.addEventListener('resize', () => { resizeCanvasToWindow(); if (state) draw(0); });
      let TILE_W = CONFIG.tileSize, TILE_H = CONFIG.tileSize;

      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
      const dist = (x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);
      const nowSec = () => performance.now()/1000;

      class RNG { constructor(seed=Math.floor(Math.random()*1e9)){this.seed=seed>>>0;} next(){let x=this.seed; x^=x<<13; x^=x>>>17; x^=x<<5; this.seed=x>>>0; return this.seed/0xffffffff;} range(a,b){return a+(b-a)*this.next();} int(a,b){return Math.floor(this.range(a,b+1));} pick(arr){return arr[this.int(0,arr.length-1)];} }

      // Smooth noise utilities for clumpy terrain
      function hash2(x, y, seed){
        let n = x * 374761393 + y * 668265263 + seed * 1442695041;
        n = (n ^ (n >>> 13)) >>> 0; n = Math.imul(n, 1274126177) >>> 0;
        n = (n ^ (n >>> 16)) >>> 0;
        return n / 4294967295;
      }
      function valueNoise(x, y, scale, seed){
        const fx = x / scale, fy = y / scale;
        const x0 = Math.floor(fx), y0 = Math.floor(fy);
        const x1 = x0 + 1, y1 = y0 + 1;
        const sx = fx - x0, sy = fy - y0;
        const v00 = hash2(x0, y0, seed), v10 = hash2(x1, y0, seed);
        const v01 = hash2(x0, y1, seed), v11 = hash2(x1, y1, seed);
        const ix0 = v00 + (v10 - v00) * (sx * sx * (3 - 2 * sx));
        const ix1 = v01 + (v11 - v01) * (sx * sx * (3 - 2 * sx));
        return ix0 + (ix1 - ix0) * (sy * sy * (3 - 2 * sy));
      }
      function fbm(x, y, scale, octaves, persistence, lacunarity, seed){
        let amp = 1, freq = 1, sum = 0, norm = 0;
        for(let i=0;i<octaves;i++){
          sum += amp * valueNoise(x*freq, y*freq, scale, seed + i*1013);
          norm += amp; amp *= persistence; freq *= lacunarity;
        }
        return sum / norm;
      }

      function generateMap(rng){
        const cols=CONFIG.mapCols, rows=CONFIG.mapRows; const grid=new Array(cols*rows);
        const noiseSeed = rng.int(0, 1e9);

        // Choose main terrain and target share between 40% and 70%
        const mains=['plains','desert','jungle','tundra'];
        const mainTerrain = mains[rng.int(0, mains.length-1)];
        const mainTarget = rng.range(0.4, 0.7);

        // Compatibility sets for secondary terrains per main
        const compat={
          plains:   ['forest','hills','mountain','river','water','lake','ocean'],
          desert:   ['savannah','hills','mountain'],
          jungle:   ['forest','savannah','hills','mountain','river','water','lake','ocean'],
          tundra:   ['snow','river','water','lake','ocean']
        };

        // Precompute main scores and set threshold by quantile to hit target share
        const mainScores = new Float32Array(cols*rows);
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const idx=r*cols+c;
            // Low frequency fbm for clumpiness
            mainScores[idx] = fbm(c, r, Math.max(cols,rows)*0.6, 4, 0.5, 2.0, noiseSeed + (mainTerrain.charCodeAt(0)<<8));
          }
        }
        // Compute threshold
        const sorted = Array.from(mainScores).sort((a,b)=>a-b);
        const threshold = sorted[Math.floor((1 - mainTarget) * sorted.length)];

        // Secondary noise functions (different seeds/scales)
        function n(type, c, r){
          switch(type){
            case 'forest':   return fbm(c, r, Math.max(cols,rows)*0.35, 4, 0.55, 2.1, noiseSeed+101);
            case 'savannah': return fbm(c, r, Math.max(cols,rows)*0.38, 4, 0.55, 2.1, noiseSeed+102);
            case 'hills':    return fbm(c, r, Math.max(cols,rows)*0.40, 3, 0.5,  2.0, noiseSeed+103);
            case 'mountain': return fbm(c, r, Math.max(cols,rows)*0.55, 5, 0.45, 2.0, noiseSeed+104);
            case 'river':    return fbm(c, r, Math.max(cols,rows)*0.90, 3, 0.6,  2.3, noiseSeed+105);
            case 'water':    return fbm(c, r, Math.max(cols,rows)*0.70, 3, 0.55, 2.1, noiseSeed+106);
            case 'lake':     return fbm(c, r, Math.max(cols,rows)*0.65, 3, 0.5,  2.0, noiseSeed+107);
            case 'ocean':    return fbm(c, r, Math.max(cols,rows)*1.20, 4, 0.55, 2.0, noiseSeed+108);
            case 'snow':     return fbm(c, r, Math.max(cols,rows)*0.50, 4, 0.5,  2.0, noiseSeed+109);
            default: return 0;
          }
        }

        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            let terrain;
            const idx=r*cols+c;
            if(mainScores[idx] >= threshold){
              terrain = mainTerrain;
            } else {
              // Pick best compatible secondary by noise strength
              const allowed = compat[mainTerrain];
              let best='plains', bestVal=-1;
              for(const k of allowed){ const v=n(k, c, r); if(v>bestVal){ bestVal=v; best=k; } }
              terrain = best;
            }
            grid[idx] = { terrain, owner: c < cols/2 ? 'blue' : 'red', control: c<cols/2 ? CONFIG.tileControlThreshold : -CONFIG.tileControlThreshold };
          }
        }

        // Enforce presence: carve oceans and rivers when compatible and scarce
        function count(type){ let ct=0; for(const t of grid) if(t.terrain===type) ct++; return ct; }
        function setTerrain(c,r,type){ if(c<0||r<0||c>=cols||r>=rows) return; grid[r*cols+c].terrain=type; }
        // Ensure ocean coastline if allowed (wavy/noisy coastline instead of straight bar)
        if(compat[mainTerrain].includes('ocean') && count('ocean') < cols*rows*0.03){
          const sideLeft = rng.next() < 0.5;
          const base = Math.max(2, Math.floor(cols * 0.03 + rng.range(0, cols*0.03)));
          const maxWidth = Math.max(base+2, Math.floor(cols * 0.14));
          const amp = Math.max(2, Math.floor(cols * 0.02 + rng.range(0, cols*0.03)));
          const period = rng.range(rows*0.35, rows*0.8);
          const k = (Math.PI*2)/period;
          const phi = rng.range(0, Math.PI*2);
          const coastSeed = noiseSeed + 777;
          for(let r=0;r<rows;r++){
            const sTerm = Math.sin(k*r + phi);
            const nTerm = fbm(0, r, Math.max(cols,rows)*0.35, 3, 0.55, 2.05, coastSeed) * 2 - 1; // [-1,1]
            let w = Math.floor(base + amp * (0.6*sTerm + 0.4*nTerm));
            w = clamp(w, 2, maxWidth);
            if(sideLeft){ for(let c=0;c<w;c++) setTerrain(c,r,'ocean'); }
            else { for(let c=cols-w;c<cols;c++) setTerrain(c,r,'ocean'); }
          }
        }
        // Carve rivers if allowed and none detected
        function carveRiver(startC){
          let c=startC, r=0; let dir=(rng.next()<0.5? -1: 1);
          while(r<rows){
            setTerrain(c,r,'river'); setTerrain(c+1,r,'river'); // 2-wide
            // meander
            if(r%3===0){ c += dir*(rng.next()<0.5?1:0); }
            // bias towards center to avoid sticking to edge
            const bias = Math.sign((cols/2)-c);
            if(r%5===0 && rng.next()<0.6) c += bias;
            c = clamp(c,1,cols-2); r++;
            // stop when we hit ocean
            if(grid[r*cols + c] && grid[r*cols + c].terrain==='ocean') break;
          }
        }
        if(compat[mainTerrain].includes('river')){
          let existingRivers = count('river');
          if(existingRivers < cols){
            const rivers = 2 + (rng.next()<0.5?1:0);
            for(let i=0;i<rivers;i++){ carveRiver(rng.int(Math.floor(cols*0.2), Math.floor(cols*0.8))); }
          }
        }

        // Smoothing pass to clump tiles (remove speckles)
        function smooth(pass){
          const copy = grid.map(t=>t.terrain);
          for(let r=1;r<rows-1;r++){
            for(let c=1;c<cols-1;c++){
              const i=r*cols+c; const t=copy[i];
              const neighbors=[copy[i-1],copy[i+1],copy[i-cols],copy[i+cols]];
              const counts={}; for(const nval of neighbors){ counts[nval]=(counts[nval]||0)+1; }
              let best=t, bestCt=0; for(const k in counts){ if(counts[k]>bestCt){ best=k; bestCt=counts[k]; } }
              if(bestCt>=3) grid[i].terrain=best;
            }
          }
        }
        smooth(); smooth();
        // Initial frontline: single smooth line at random angle with gentle curvature
        const mid = { x: cols/2, y: rows/2 };
        const theta = rng.range(0, Math.PI*2);
        const nx = Math.cos(theta), ny = Math.sin(theta); // normal
        const tx = -ny, ty = nx; // tangent
        const period = rng.range(Math.max(cols,rows)*0.8, Math.max(cols,rows)*1.6);
        const k = (Math.PI*2)/period;
        const amp = rng.range(Math.max(cols,rows)*0.04, Math.max(cols,rows)*0.12);
        const phi = rng.range(0, Math.PI*2);
        function signed(pcx, pry){
          const dx = pcx - mid.x, dy = pry - mid.y;
          const t = dx*tx + dy*ty;
          const curve = amp * Math.sin(k * t + phi);
          const s = dx*nx + dy*ny - curve;
          return s;
        }
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const s = signed(c+0.5, r+0.5);
            const t=grid[r*cols+c];
            if(s<0){ t.owner='blue'; t.control=CONFIG.tileControlThreshold; }
            else { t.owner='red'; t.control=-CONFIG.tileControlThreshold; }
          }
        }
        grid.frontline = { theta, amp, k, phi, center: mid };

        // Adjust final share to ensure main terrain is within 40%-70%
        const mainCount = grid.filter(t=>t.terrain===mainTerrain).length;
        const fraction = mainCount / grid.length;
        if (fraction < 0.4 || fraction > 0.7) {
          const target = clamp(mainTarget, 0.4, 0.7);
          const need = Math.floor(target * grid.length) - mainCount;
          if (need > 0) {
            // Promote strong-main candidates
            const candidates = [];
            for(let r=0;r<rows;r++){
              for(let c=0;c<cols;c++){
                const i=r*cols+c; const t=grid[i]; if(t.terrain===mainTerrain) continue;
                // Recompute local main strength cheaply
                const local = Math.random(); // fallback randomness to avoid heavy recomputation
                candidates.push({i,score:local});
              }
            }
            candidates.sort((a,b)=>b.score-a.score);
            for(let k=0;k<Math.min(need,candidates.length);k++) grid[candidates[k].i].terrain = mainTerrain;
          } else if (need < 0) {
            // Demote some main tiles near secondary strengths randomly
            let toDemote = -need;
            for(let r=0;r<rows && toDemote>0;r++){
              for(let c=0;c<cols && toDemote>0;c++){
                const i=r*cols+c; const t=grid[i]; if(t.terrain!==mainTerrain) continue;
                if (Math.random()<0.2){ t.terrain = 'plains'; toDemote--; }
              }
            }
          }
        }
        return {cols, rows, tiles:grid};
      }
      function tileAt(map,c,r){ if(c<0||r<0||c>=map.cols||r>=map.rows) return null; return map.tiles[r*map.cols+c]; }
      function worldToCell(x,y){
        const cols = (state && state.map ? state.map.cols : CONFIG.mapCols);
        const rows = (state && state.map ? state.map.rows : CONFIG.mapRows);
        return { c: clamp(Math.floor(x/TILE_W),0,cols-1), r: clamp(Math.floor(y/TILE_H),0,rows-1) };
      }
      function cellCenter(c,r){ return { x: (c+0.5)*TILE_W, y: (r+0.5)*TILE_H }; }

      // Pathfinding context (used to allow infantry to cross water extremely slowly and choose direct routing)
      let PATHFINDING_CONTEXT = { isTank: false, prefersDirect: false };

      // A* on grid (supports naval)
      function findPath(map, startC,startR,endC,endR, isNaval=false){
        const cols=map.cols, rows=map.rows; const start=startR*cols+startC; const goal=endR*cols+endC;
        const closed=new Uint8Array(cols*rows); const g=new Float32Array(cols*rows); const f=new Float32Array(cols*rows); const came=new Int32Array(cols*rows); const inOpen=new Uint8Array(cols*rows);
        came.fill(-1); for(let i=0;i<g.length;i++){g[i]=Infinity; f[i]=Infinity;}
        g[start]=0;
        const h=(i)=>{const c=i%cols, r=(i/cols)|0; return Math.abs(c-endC)+Math.abs(r-endR);} ; f[start]=h(start);
        const open=[start]; inOpen[start]=1;
        const up=(i)=>{while(i>0){const p=(i-1)>>1; if(f[open[p]]<=f[open[i]]) break; [open[p],open[i]]=[open[i],open[p]]; i=p;}};
        const down=(i)=>{for(;;){let l=(i<<1)+1, r=l+1, s=i; if(l<open.length && f[open[l]]<f[open[s]]) s=l; if(r<open.length && f[open[r]]<f[open[s]]) s=r; if(s===i) break; [open[s],open[i]]=[open[i],open[s]]; i=s;}};
        const push=(n)=>{open.push(n); inOpen[n]=1; up(open.length-1);} ;
        const pop=()=>{const t=open[0]; const last=open.pop(); if(open.length){open[0]=last; down(0);} inOpen[t]=0; return t;};
        const passableCell=(c,r)=>{
          const t=tileAt(map,c,r); if(!t) return false;
          if(isNaval) return CONFIG.terrain[t.terrain].navalMove !== Infinity;
          if(CONFIG.terrain[t.terrain].move!==Infinity){
            // If preferring direct routes, mildly penalize entering slower tiles instead of optimizing speed
            return true;
          }
          // Allow infantry (non-tank) to cross water tiles
          if(!PATHFINDING_CONTEXT.isTank && (t.terrain==='ocean' || t.terrain==='lake' || t.terrain==='water')) return true;
          return false;
        };
        const moveCost=(fc,fr,tc,tr)=>{
          const t=tileAt(map,tc,tr);
          const d=(fc!==tc && fr!==tr)?Math.SQRT2:1;
          if(isNaval) return d*CONFIG.terrain[t.terrain].navalMove;
          const mv = CONFIG.terrain[t.terrain].move;
          if(mv!==Infinity){
            // When preferring direct routes, ignore terrain speed; use geometric step cost only
            if(PATHFINDING_CONTEXT.prefersDirect) return d;
            return d*mv;
          }
          // Infantry water crossing: extremely slow on ocean/lake/water
          if(!PATHFINDING_CONTEXT.isTank && (t.terrain==='ocean' || t.terrain==='lake' || t.terrain==='water')) return d*CONFIG.infantryWaterMove;
          return Infinity;
        };
        while(open.length){
          const cur=pop(); if(cur===goal){ const path=[]; let p=cur; while(p!==start){ path.push({c:p%cols, r:(p/cols)|0}); p=came[p]; } path.push({c:startC,r:startR}); path.reverse(); return path; }
          closed[cur]=1; const cc=cur%cols, rr=(cur/cols)|0;
          for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
            if(!dc && !dr) continue; const nc=cc+dc, nr=rr+dr; if(!passableCell(nc,nr)) continue; const ni=nr*cols+nc; if(closed[ni]) continue; const tg=g[cur]+moveCost(cc,rr,nc,nr); if(tg<g[ni]){came[ni]=cur; g[ni]=tg; f[ni]=tg+h(ni); if(!inOpen[ni]) push(ni);} }
        }
        return null;
      }

      class Unit{
        constructor(x,y,side,isTank=false){ this.x=x; this.y=y; this.side=side; this.isTank=isTank; const a=isTank?CONFIG.tankUnit:CONFIG.baseUnit; this.radius=a.radius; this.baseSpeed=a.baseSpeed; this.baseSpeedOriginal=this.baseSpeed; this.baseSpeedBaseline=this.baseSpeed; this.maxHp=a.hp; this.maxHpOriginal=this.maxHp; this.hp=this.maxHp; this.dps=a.dps; this.selected=false; this.path=null; this.pathIndex=0; this.target=null; this.engaged=false; this.lockedForCombat=false; this.retreatUntil=0; this.isRetreating=false; this.lastPos={x,y}; this.type='land'; }
        setTarget(x,y,map){ this.target={x,y}; const s=worldToCell(this.x,this.y); const e=worldToCell(x,y); PATHFINDING_CONTEXT.isTank = !!this.isTank; const path=findPath(map,s.c,s.r,e.c,e.r,false); this.path=path; this.pathIndex=0; this.retreatUntil = nowSec() + CONFIG.controls.retreatGrace; }
        update(dt,map){
          // Movement is skipped if locked in combat
          const canForceMove = nowSec() < this.retreatUntil; // potential retreat window
          this.engaged = this.lockedForCombat;
          if(this.path && this.pathIndex < this.path.length){
            // If enemies block next waypoint within collision radius, do not advance unless not blocked
            let advancementAllowed = true;
            const nextNode = this.path[this.pathIndex];
            const nextCenter = nextNode ? cellCenter(nextNode.c, nextNode.r) : null;
            if(nextCenter){
              const nearby = getUnitsInRadius(nextCenter.x, nextCenter.y, CONFIG.engageRadius+4);
              const blockers = nearby.some(n => n.side !== this.side);
              if(blockers) advancementAllowed = false;
            }
            // If currently in combat, can advance only within own controlled territory
            if(this.lockedForCombat){
              const canGo = isPathInsideOwnedTerritory(this, this.pathIndex, map);
              advancementAllowed = advancementAllowed && canGo;
            }
            // moving back counts as retreat
            this.isRetreating = false;
            if(nextCenter){ const toNextX = nextCenter.x - this.x; const toNextY = nextCenter.y - this.y; const lastMoveX = this.x - this.lastPos.x; const lastMoveY = this.y - this.lastPos.y; const dot = toNextX*lastMoveX + toNextY*lastMoveY; if(dot < 0) this.isRetreating = true; }

            // Only allow movement when corridor is clear (forward), or when retreating and corridor is clear behind
            // Do not re-path or alter course once a player order has been given; follow current path until reached
            if(advancementAllowed || (canForceMove && this.isRetreating)){
            const node=this.path[this.pathIndex]; const {x:tx,y:ty}=cellCenter(node.c,node.r); const dx=tx-this.x, dy=ty-this.y; const d=Math.hypot(dx,dy);
            const tile=tileAt(map,node.c,node.r);
            let moveDivisor=CONFIG.terrain[tile.terrain].move;
            if(moveDivisor===Infinity && !this.isTank && (tile.terrain==='ocean' || tile.terrain==='lake' || tile.terrain==='water')){
              moveDivisor = CONFIG.infantryWaterMove;
            }
            const speed = moveDivisor===Infinity ? 0 : this.baseSpeed / moveDivisor; const step=speed*dt;
            if(d<=step){ this.lastPos={x:this.x,y:this.y}; this.x=tx; this.y=ty; this.pathIndex++; if(this.pathIndex>=this.path.length){ this.path=null; this.pathIndex=0; } }
            else { this.lastPos={x:this.x,y:this.y}; this.x += (dx/d)*step; this.y += (dy/d)*step; }
            }
          }
          // Formation persistence (only when explicitly marked persistent)
          if(this.formation && this.formation.persistent && (!this.path || this.path.length===0)){
            const f=this.formation; const N=1; // per unit recompute own slot target
            const pts=f.points; if(pts && pts.length>1){
              const total=f.totalLength; const k=f.slotIndex+1; const d=(k/(f.slotIndexCount||0 || (pts.length))) * total; // fallback
              // better: normalize by intended count: reuse slotIndex with Nknown passed via formationCount
              const desiredDist = (k/((f.count||0)||1+1))*total;
              const tgt = (function pointAtDist(d){ let acc=0; for(let i=1;i<pts.length;i++){ const ax=pts[i-1].x, ay=pts[i-1].y, bx=pts[i].x, by=pts[i].y; const segLen=Math.hypot(bx-ax,by-ay); if(acc+segLen >= d){ const t=(d-acc)/segLen; return {x:ax+(bx-ax)*t, y:ay+(by-ay)*t}; } acc+=segLen; } return pts[pts.length-1]; })(desiredDist);
              const dx=tgt.x-this.x, dy=tgt.y-this.y; const distTo=Math.hypot(dx,dy);
              if(distTo>CONFIG.formation.retargetPx){ this.setTarget(tgt.x, tgt.y, map); }
            }
          }
          // Territory capture from presence (instant paint) with dynamic radius slightly larger than unit
          const cell=worldToCell(this.x,this.y);
          const radiusPx = this.radius + 8; // slightly bigger than unit
          const radX = Math.ceil(radiusPx / TILE_W);
          const radY = Math.ceil(radiusPx / TILE_H);
          for(let dr=-radY; dr<=radY; dr++){
            for(let dc=-radX; dc<=radX; dc++){
              const c = clamp(cell.c+dc, 0, map.cols-1), r = clamp(cell.r+dr, 0, map.rows-1);
              const tt = tileAt(map,c,r);
              if(!tt || CONFIG.terrain[tt.terrain].move === Infinity) continue;
              const center = cellCenter(c,r);
              const maxDist = radiusPx + Math.max(TILE_W,TILE_H)*0.3;
              const dx = center.x - this.x, dy = center.y - this.y;
              if(dx*dx + dy*dy > maxDist*maxDist) continue;
              const nearby = getUnitsInRadius(center.x, center.y, CONFIG.captureBlockRadius);
              const enemyNearby = nearby.some(n => n.side !== this.side);
              if(!enemyNearby){ tt.control = (this.side==='blue' ? 1 : -1) * CONFIG.tileControlThreshold; }
              if(tt.control>=CONFIG.tileControlThreshold*0.5) tt.owner='blue';
              if(tt.control<=-CONFIG.tileControlThreshold*0.5) tt.owner='red';
            }
          }
          // Terrain-based healing or attrition
          const curTile = tileAt(map, cell.c, cell.r);
          if(curTile){ const heal = CONFIG.terrain[curTile.terrain].healPerSecond || 0; if(heal !== 0){ this.hp = clamp(this.hp + heal*dt, 0, this.maxHp); } }
        }
        draw(ctx){
          const team=CONFIG.team[this.side]; const shake=this.engaged ? (Math.random()-0.5)*1.2 : 0; ctx.save(); ctx.translate(shake,shake);
          ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=team.color; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=team.outline; ctx.stroke();
          if(this.isTank){ ctx.beginPath(); const s=this.radius*1.1; ctx.rect(this.x-s/2,this.y-s/2,s,s); ctx.strokeStyle='#111'; ctx.lineWidth=1.4; ctx.stroke(); }
          if(this.selected){ ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+3,0,Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.9)'; ctx.lineWidth=1.2; ctx.stroke(); }
          if(this.hp < this.maxHp){ const pct=clamp(this.hp/this.maxHp,0,1); ctx.beginPath(); ctx.strokeStyle = pct>0.5 ? '#5fe35f' : (pct>0.25 ? '#ffd056' : '#ff6b6b'); ctx.lineWidth=2; ctx.arc(this.x,this.y,this.radius+5,-Math.PI/2,-Math.PI/2+Math.PI*2*pct); ctx.stroke(); }
          ctx.restore();
        }
      }

      class City{
        constructor(x,y,side,isCapital=false){ this.x=x; this.y=y; this.side=side; this.isCapital=isCapital; this.spawnTimer=0; this.control=(this.side==='blue'?1:-1)*CONFIG.cityCaptureThreshold; this.radius=12; this.alive=true; this.isHarbor=false; }
        update(dt,map){
          const influenceRadius=32; const nearUnits=getUnitsInRadius(this.x,this.y,influenceRadius);
          for(const u of nearUnits){ const delta=CONFIG.cityCapturePerSecond*dt*(u.side==='blue'?1:-1); this.control=clamp(this.control+delta,-CONFIG.cityCaptureThreshold,CONFIG.cityCaptureThreshold); }
          const was=this.side; if(this.control>=CONFIG.cityCaptureThreshold*0.5) this.side='blue'; if(this.control<=-CONFIG.cityCaptureThreshold*0.5) this.side='red';
          if(this.side!==was){ const cell=worldToCell(this.x,this.y); for(let dr=-2; dr<=2; dr++) for(let dc=-2; dc<=2; dc++){ const c=clamp(cell.c+dc,0,map.cols-1), r=clamp(cell.r+dr,0,map.rows-1); const t=tileAt(map,c,r); if(!t) continue; t.owner=this.side; t.control=(this.side==='blue'?1:-1)*CONFIG.tileControlThreshold; } }
          // Pause production if combat near city
          const hasCombatNearby = nearUnits.some(u=>{
            const others = getUnitsInRadius(u.x, u.y, CONFIG.engageRadius);
            return others.some(o=>o.side!==u.side);
          });
          if(!hasCombatNearby){
            this.spawnTimer+=dt;
            const interval = this.isCapital ? CONFIG.spawn.capitalSeconds : CONFIG.spawn.citySeconds;
            if(this.spawnTimer>=interval){
              this.spawnTimer=0;
              spawnUnitNearCity(this);
              if(this.isCapital){ spawnUnitNearCity(this); }
            }
          } else {
            this.spawnTimer = 0; // reset while under attack
          }
        }
        draw(ctx){ const team=CONFIG.team[this.side]; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius+8,0,Math.PI*2); ctx.fillStyle=this.isCapital?'rgba(255,215,64,0.12)':'rgba(255,255,255,0.06)'; ctx.fill(); ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.fillStyle=team.color; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=team.outline; ctx.stroke(); if(this.isCapital){ drawStar(ctx,this.x,this.y,5,this.radius*0.8,this.radius*0.4,'#ffd740'); } else { ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); } const pct=(this.control+CONFIG.cityCaptureThreshold)/(2*CONFIG.cityCaptureThreshold); ctx.beginPath(); ctx.lineWidth=3; ctx.strokeStyle='#ffd740'; ctx.arc(this.x,this.y,this.radius+11,-Math.PI/2,-Math.PI/2+Math.PI*2*pct); ctx.stroke(); }
      }
      function drawStar(ctx,x,y,spikes,outerRadius,innerRadius,color){ let rot=Math.PI/2*3; let step=Math.PI/spikes; ctx.beginPath(); ctx.moveTo(x,y-outerRadius); for(let i=0;i<spikes;i++){ let cx=x+Math.cos(rot)*outerRadius, cy=y+Math.sin(rot)*outerRadius; ctx.lineTo(cx,cy); rot+=step; cx=x+Math.cos(rot)*innerRadius; cy=y+Math.sin(rot)*innerRadius; ctx.lineTo(cx,cy); rot+=step; } ctx.lineTo(x,y-outerRadius); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); }

      // Spatial hashing
      let spatial;
      function rebuildSpatial(){ const cols=Math.ceil(canvas.width/40), rows=Math.ceil(canvas.height/40); const cells=new Array(cols*rows); for(let i=0;i<cells.length;i++) cells[i]=[]; const index=(x,y)=>{const c=clamp(Math.floor(x/40),0,cols-1); const r=clamp(Math.floor(y/40),0,rows-1); return r*cols+c;}; for(const u of state.units) cells[index(u.x,u.y)].push(u); spatial={cols,rows,cells,index}; }
      function getUnitsInRadius(x,y,radius){
        const results=[]; if(!spatial) return results;
        const minC=clamp(Math.floor((x-radius)/40),0,spatial.cols-1);
        const maxC=clamp(Math.floor((x+radius)/40),0,spatial.cols-1);
        const minR=clamp(Math.floor((y-radius)/40),0,spatial.rows-1);
        const maxR=clamp(Math.floor((y+radius)/40),0,spatial.rows-1);
        const r2 = radius*radius;
        for(let r=minR;r<=maxR;r++) for(let c=minC;c<=maxC;c++){
          const arr=spatial.cells[r*spatial.cols+c];
          for(const u of arr){ const dx=u.x-x, dy=u.y-y; if(dx*dx+dy*dy<=r2) results.push(u); }
        }
        return results;
      }

      // Check if a unit's planned path corridor is free of enemy units
      function isPathCorridorClear(unit, startIndex){
        if(!unit.path || startIndex>=unit.path.length) return true;
        let p0 = { x: unit.x, y: unit.y };
        const R = CONFIG.engageRadius + 8;
          const lookAhead = Math.min(unit.path.length - 1, startIndex + 3);
        for(let i=startIndex; i<=lookAhead; i++){
          const node = unit.path[i];
          const p1 = cellCenter(node.c, node.r);
          const dx = p1.x - p0.x, dy = p1.y - p0.y; const len = Math.hypot(dx,dy);
          if(len === 0){ p0 = p1; continue; }
          const step = Math.max(8, R * 0.7);
          for(let s=0; s<=len; s+=step){
            const sx = p0.x + dx * (s/len), sy = p0.y + dy * (s/len);
            const near = getUnitsInRadius(sx, sy, R);
            if(near.some(n => n.side !== unit.side)) return false;
          }
          p0 = p1;
        }
        return true;
      }

      function isPathInsideOwnedTerritory(unit, startIndex, map){
        if(!unit.path || startIndex>=unit.path.length) return true;
        const lookAhead = Math.min(unit.path.length - 1, startIndex + 3);
        for(let i=startIndex; i<=lookAhead; i++){
          const node = unit.path[i];
          const t = tileAt(map, node.c, node.r);
          if(!t) continue;
          if((unit.side === 'blue' && t.owner !== 'blue') || (unit.side === 'red' && t.owner !== 'red')){
            return false;
          }
        }
        return true;
      }

      // Game state
      let state=null;
      function createGame(seed){ const rng=new RNG(seed); const map=generateMap(rng); const cities=[]; function placeCity(side,isCapital){ for(let tries=0; tries<6000; tries++){ const c = rng.int(2, map.cols-3); const r=rng.int(3,map.rows-4); const t=tileAt(map,c,r); if(!t) continue; // must be owned by side at start
            if(t.owner!==side) continue; if(['ocean','lake','water','river','mountain'].includes(t.terrain)) continue; const {x,y}=cellCenter(c,r); if(cities.some(ci=>dist(ci.x,ci.y,x,y)<100)) continue; cities.push(new City(x,y,side,isCapital)); return; } }
        for(const side of ['blue','red']){ placeCity(side,true); for(let i=0;i<4;i++) placeCity(side,false); }
        // Place harbors
        function isCoastForSide(c,r,side){ const t=tileAt(map,c,r); if(!t) return false; if(t.owner!==side) return false; if(['ocean','lake','water','river'].includes(t.terrain)) return false; const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; for(const [dc,dr] of dirs){ const tt=tileAt(map,c+dc,r+dr); if(tt && ['ocean','lake','water','river'].includes(tt.terrain)) return true; } return false; }
        // Harbors removed: no special naval spawns; coast cities are regular cities
        const units=[]; const lastPlanAt={red:0, blue:0}; const st={ rng, map, cities, units, lastPlanAt, startedAt: nowSec(), paused:false, winner:null, allowCombat:false, countdownActive:true, difficulty: 'normal' };
        // Initial frontline troops on both sides
        spawnFrontlineUnits(st);
        return st; }

      function createGameFromScenario(scen){
        const rng = new RNG(Math.floor(Math.random()*1e9));
        const cols = Math.max(10, Math.floor(scen.cols || CONFIG.mapCols));
        const rows = Math.max(10, Math.floor(scen.rows || CONFIG.mapRows));
        const tiles = new Array(cols*rows);
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const i=r*cols+c;
            const sTile = Array.isArray(scen.tiles) ? scen.tiles[i] : null;
            const terrain = (sTile && CONFIG.terrain[sTile.terrain]) ? sTile.terrain : 'plains';
            const owner = (sTile && (sTile.owner==='blue' || sTile.owner==='red')) ? sTile.owner : (c<cols/2? 'blue':'red');
            const control = (sTile && typeof sTile.control === 'number') ? sTile.control : (owner==='blue'? CONFIG.tileControlThreshold : -CONFIG.tileControlThreshold);
            tiles[i] = { terrain, owner, control };
          }
        }
        const map = { cols, rows, tiles };
        if(scen.frontline){ map.frontline = scen.frontline; }
        const cities=[];
        if(Array.isArray(scen.cities)){
          for(const ci of scen.cities){ if(!ci) continue; const x = clamp(ci.x||0, 0, canvas.width); const y = clamp(ci.y||0, 0, canvas.height); const side = (ci.side==='red')?'red':'blue'; const isCapital = !!ci.isCapital; cities.push(new City(x,y,side,isCapital)); }
        }
        const units=[];
        if(Array.isArray(scen.units)){
          for(const u of scen.units){ if(!u) continue; const x = clamp(u.x||0, 0, canvas.width); const y = clamp(u.y||0, 0, canvas.height); const side = (u.side==='red')?'red':'blue'; const isTank = !!u.isTank; units.push(new Unit(x,y,side,isTank)); }
        }
        const lastPlanAt={red:0, blue:0};
        const st={ rng, map, cities, units, lastPlanAt, startedAt: nowSec(), paused:false, winner:null, allowCombat:false, countdownActive:true, difficulty: 'normal', scenario: scen };
        CONFIG.mapCols = cols; CONFIG.mapRows = rows; resizeCanvasToWindow();
        return st;
      }

      function terrainPassable(t){ return CONFIG.terrain[t.terrain].move !== Infinity; }
      function terrainSpawnableForLand(t){ return CONFIG.terrain[t.terrain].move !== Infinity && t.terrain !== 'river'; }
      function spawnFrontlineUnits(st){
        const {map}=st; const cols=map.cols, rows=map.rows; const fl = map.tiles.frontline || map.frontline || {};
        const theta = fl.theta ?? Math.random()*Math.PI*2; const nx=Math.cos(theta), ny=Math.sin(theta); const tx=-ny, ty=nx;
        const center = fl.center || { x: cols/2, y: rows/2 };
        const k = fl.k ?? (2*Math.PI/Math.max(cols,rows)); const amp = fl.amp ?? (Math.max(cols,rows)*0.08);
        const phi = fl.phi ?? Math.random()*Math.PI*2;
        function curvePoint(t){ // in cell space
          const cx = center.x + t*tx + amp*Math.sin(k*t + phi)*nx;
          const cy = center.y + t*ty + amp*Math.sin(k*t + phi)*ny;
          return { x: cx, y: cy };
        }
        function isBlue(c,r){ const dx=(c+0.5)-center.x, dy=(r+0.5)-center.y; const tt=dx*tx+dy*ty; const s=dx*nx+dy*ny - amp*Math.sin(k*tt+phi); return s<0; }
        function findNearestPassableCell(cx, cy, side){ const maxRad=6; for(let rad=0; rad<=maxRad; rad++){ for(let dr=-rad; dr<=rad; dr++){ for(let dc=-rad; dc<=rad; dc++){ if(Math.abs(dc)!==rad && Math.abs(dr)!==rad) continue; const c=clamp(Math.round(cx)+dc,1,cols-2), r=clamp(Math.round(cy)+dr,1,rows-2); const t=tileAt(map,c,r); if(!t) continue; if((side==='blue' && isBlue(c,r)) || (side==='red' && !isBlue(c,r))){ if(terrainSpawnableForLand(t)) return {c,r}; } } } } return null; }
        const offsetCells = Math.max(3, Math.ceil((CONFIG.engageRadius+12)/TILE_W));
        const stepCells = Math.max(2, CONFIG.frontline.rowStep);
        const maxLen = Math.hypot(cols, rows);
        const targets=[];
        for(let t=-maxLen; t<=maxLen; t+=stepCells){ const p=curvePoint(t); if(p.x>1 && p.x<cols-1 && p.y>1 && p.y<rows-1) targets.push(p); }
        const count = CONFIG.frontline.unitsPerSidePerRow;
        for(const p of targets){
          // Blue target offset along -normal
          const bcx = p.x - nx*offsetCells, bcy = p.y - ny*offsetCells;
          const rcx = p.x + nx*offsetCells, rcy = p.y + ny*offsetCells;
          const bCell=findNearestPassableCell(bcx,bcy,'blue');
          const rCell=findNearestPassableCell(rcx,rcy,'red');
          if(bCell){ const base=cellCenter(bCell.c,bCell.r); for(let i=0;i<count;i++){ const j=(Math.random()-0.5)*CONFIG.frontline.jitter; const u=new Unit(base.x, base.y+j, 'blue', Math.random()<0.18); st.units.push(u);} }
          if(rCell){ const base=cellCenter(rCell.c,rCell.r); for(let i=0;i<count;i++){ const j=(Math.random()-0.5)*CONFIG.frontline.jitter; const u=new Unit(base.x, base.y+j, 'red', Math.random()<0.18); st.units.push(u);} }
        }
      }

      function spawnUnitNearCity(city){
        // Land-only spawn: avoid water/ocean/lake/river tiles (still crossable, but no spawns on rivers)
        for(let tries=0; tries<50; tries++){
          const angle=Math.random()*Math.PI*2; const radius=city.radius+10+Math.random()*12; const x=city.x+Math.cos(angle)*radius; const y=city.y+Math.sin(angle)*radius;
          const cell=worldToCell(x,y); const t=tileAt(state.map, cell.c, cell.r);
          if(!t) continue; const terr=t.terrain; if(['ocean','lake','water','river'].includes(terr)) continue; // exclude river too
          const isTank=Math.random()<CONFIG.tankChance; state.units.push(new Unit(x,y,city.side,isTank)); break;
        }
      }

      // Naval units removed

      // Input
      let mouse={x:0,y:0}; let drag=null;
      canvas.addEventListener('mousemove',e=>{ const rect=canvas.getBoundingClientRect(); mouse.x=e.clientX-rect.left; mouse.y=e.clientY-rect.top; if(editor && editor.mode){ if(editor.dragging){ editorPaintAtMouse(); } return; } if(state && state.spectate) return; if(drag){ drag.x1=mouse.x; drag.y1=mouse.y; } });
      canvas.addEventListener('mousedown',e=>{ if(state.winner) return; if(editor && editor.mode){ if(e.button===0){ editorMouseDown('left'); } if(e.button===2){ editorMouseDown('right'); e.preventDefault(); } return; } if(state && state.spectate) return; if(e.button===0){ drag={x0:mouse.x,y0:mouse.y,x1:mouse.x,y1:mouse.y}; }});
      canvas.addEventListener('mouseup',e=>{ if(state.winner) return; if(editor && editor.mode){ editor.dragging=false; return; } if(state && state.spectate){ drag=null; return; } if(e.button===0){ const box=drag; drag=null; if(!box) return; const moved=Math.hypot(box.x1-box.x0,box.y1-box.y0)>4; if(moved){ const minX=Math.min(box.x0,box.x1), maxX=Math.max(box.x0,box.x1); const minY=Math.min(box.y0,box.y1), maxY=Math.max(box.y0,box.y1); for(const u of state.units) u.selected=false; for(const u of state.units){ if(u.side!=='blue') continue; if(u.x>=minX && u.x<=maxX && u.y>=minY && u.y<=maxY) u.selected=true; } } else { let picked=null, best=12; for(const u of state.units){ if(u.side!=='blue') continue; const d=Math.hypot(u.x-mouse.x,u.y-mouse.y); if(d<best){ best=d; picked=u; } } if(picked){ for(const u of state.units) u.selected=false; picked.selected=true; } } }});
      // Right-click drag formation line (offensive line) instead of path following
      let rdrag=null; // {points:[{x,y}], active:boolean}
      let suppressContextMenuOnce=false;
      canvas.addEventListener('contextmenu',e=>{
        e.preventDefault(); if(state.winner) return false; if(editor && editor.mode) return false;
        if(state.spectate) return false; // disable player orders in spectate
        if(suppressContextMenuOnce){ suppressContextMenuOnce=false; return false; }
        const selected=state.units.filter(u=>u.selected && u.side==='blue');
        // If not dragging a line (or line too short), treat as single-click ring formation
        const isDraggingLine = rdrag && rdrag.active && rdrag.points && rdrag.points.length>1;
          if(selected.length && !isDraggingLine){
          const center={x:mouse.x,y:mouse.y}; const ring=Math.max(18, Math.sqrt(selected.length)*10);
          for(let i=0;i<selected.length;i++){
            const angle=(i/selected.length)*Math.PI*2; const x=center.x+Math.cos(angle)*ring; const y=center.y+Math.sin(angle)*ring;
            PATHFINDING_CONTEXT.prefersDirect = true; selected[i].setTarget(x,y,state.map); selected[i].lockedForCombat=false;
          }
        }
        return false;
      });
      canvas.addEventListener('mousedown', e=>{ if(editor && editor.mode) return; if(state.spectate) return; if(e.button===2){ rdrag={points:[{x:mouse.x,y:mouse.y}], active:true}; } });
      canvas.addEventListener('mousemove', e=>{ if(editor && editor.mode) return; if(rdrag && rdrag.active){ const last=rdrag.points[rdrag.points.length-1]; const dx=mouse.x-last.x, dy=mouse.y-last.y; if(Math.hypot(dx,dy)>10){ rdrag.points.push({x:mouse.x,y:mouse.y}); } } });
      window.addEventListener('mouseup', e=>{
        if(editor && editor.mode) return; if(rdrag && e.button===2){ if(state.spectate){ rdrag=null; return; }
          const selected=state.units.filter(u=>u.selected && u.side==='blue');
          if(selected.length && rdrag.points.length>1){
            const pts=rdrag.points.slice();
            // Polyline total length
            let total=0; for(let i=1;i<pts.length;i++) total+=Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
             // Assign each unit to the closest point on the drawn line (direct mapping, avoids crossing)
             const N=selected.length; const targets=new Array(N);
             function closestPointToPolyline(p){
               let best={x:pts[0].x,y:pts[0].y}, bestD=Infinity;
               for(let i=1;i<pts.length;i++){
                 const ax=pts[i-1].x, ay=pts[i-1].y, bx=pts[i].x, by=pts[i].y;
                 const abx=bx-ax, aby=by-ay; const apx=p.x-ax, apy=p.y-ay; const ab2=abx*abx+aby*aby; const t=ab2? Math.max(0, Math.min(1, (apx*abx+apy*aby)/ab2)) : 0;
                 const cx=ax+abx*t, cy=ay+aby*t; const dd=(cx-p.x)*(cx-p.x)+(cy-p.y)*(cy-p.y);
                 if(dd<bestD){ bestD=dd; best.x=cx; best.y=cy; }
               }
               return best;
             }
             // Cover the whole line: sample M evenly spaced points along the polyline and assign nearest unit to each
             function pointAtDist(d){ let acc=0; for(let i=1;i<pts.length;i++){ const ax=pts[i-1].x, ay=pts[i-1].y, bx=pts[i].x, by=pts[i].y; const segLen=Math.hypot(bx-ax,by-ay); if(acc+segLen>=d){ const t=(d-acc)/segLen; return {x:ax+(bx-ax)*t, y:ay+(by-ay)*t}; } acc+=segLen; } return pts[pts.length-1]; }
             const M = Math.max(N, Math.ceil(total/60)); // ensure dense coverage for long lines (about every 60px)
             const lineSamples = [];
             for(let k=0;k<M;k++){ const d = (k/(M-1))*total; lineSamples.push(pointAtDist(d)); }
             // Assign each sample to the nearest unit (Hungarian could be used; greedy approx here)
             const available = new Set(selected.map((_,i)=>i));
             const assignments = [];
             for(let si=0; si<lineSamples.length && available.size>0; si++){
               const s = lineSamples[si]; let bestU=-1, bestD=Infinity;
               for(const ui of available){ const u=selected[ui]; const dd=(u.x-s.x)*(u.x-s.x)+(u.y-s.y)*(u.y-s.y); if(dd<bestD){ bestD=dd; bestU=ui; } }
               if(bestU!==-1){ assignments.push({ui:bestU, target:s}); available.delete(bestU); }
             }
             // If more units than samples, duplicate neighbors to fill remaining
             const remainingUnits = Array.from(available);
             for(const ui of remainingUnits){
               let bestS=-1, bestD=Infinity; for(let si=0; si<lineSamples.length; si++){ const s=lineSamples[si]; const dd=(selected[ui].x-s.x)*(selected[ui].x-s.x)+(selected[ui].y-s.y)*(selected[ui].y-s.y); if(dd<bestD){ bestD=dd; bestS=si; } }
               assignments.push({ui, target: lineSamples[bestS]});
             }
             // Build final targets array in unit order
             for(let i=0;i<N;i++){ const a = assignments.find(x=>x.ui===i); targets[i] = a ? a.target : closestPointToPolyline({x:selected[i].x,y:selected[i].y}); }
             // Assign targets with formation metadata
             const formationId = Math.floor(Math.random()*1e9);
             for(let i=0;i<N;i++){
              const u=selected[i]; const tgt=targets[i];
               u.formation = { id: formationId, points: pts, slotIndex: i, totalLength: total, count: N, persistent: false };
               PATHFINDING_CONTEXT.prefersDirect = true; u.setTarget(tgt.x, tgt.y, state.map); u.lockedForCombat=false;
            }
            // prevent contextmenu ring override after draw commit
            suppressContextMenuOnce=true; setTimeout(()=>{ suppressContextMenuOnce=false; }, 100);
          }
          rdrag=null;
        }
      });
      window.addEventListener('keydown',e=>{ if(e.code==='KeyE'){ setEditorMode(!(editor && editor.mode)); updateUIVisibility(); }
        if(editor && editor.mode){ if(e.code==='Space'){ state.paused=!state.paused; updateUIVisibility(); } return; }
        if(e.code==='KeyA'){ for(const u of state.units) u.selected=(u.side==='blue'); } else if(e.code==='Space'){ state.paused=!state.paused; updateUIVisibility(); } else if(e.code==='KeyR'){ restart(); } });

      restartBtn.addEventListener('click',()=>restart()); playAgain.addEventListener('click',()=>restart());
      function restart(){ overlay.classList.remove('show'); setEditorMode(false); resizeCanvasToWindow(); state = (state && state.scenario) ? createGameFromScenario(state.scenario) : createGame(); // show start
        startOverlay.classList.remove('hidden'); countdownEl.textContent=''; updateUIVisibility(); }

      // Start flow with countdown and combat lock
      // Spectate options show/hide
      (function(){ const chk=document.getElementById('spectateChk'); const opt=document.getElementById('spectateOptions'); if(chk&&opt){ chk.addEventListener('change',()=>{ opt.style.display = chk.checked? 'block':'none'; }); } })();

      startBtn.addEventListener('click', ()=>{
        if(!state) return; setEditorMode(false); let remaining=5; countdownEl.textContent=String(remaining);
        state.difficulty = getSelectedDifficulty();
        state.aggression = getSelectedAggression();
        state.countdownActive=true; state.allowCombat=false; startBtn.disabled=true;
        state.speedPreset = getSelectedSpeed();
        state.spectate = getSpectate();
        if(state.spectate){ state.difficultyBlue = getSelectedDifficultyBlue(); state.aggressionBlue = getSelectedAggressionBlue(); } else { state.difficultyBlue = state.difficulty; state.aggressionBlue = state.aggression; }
        const id=setInterval(()=>{
          remaining--; if(remaining>0){ countdownEl.textContent=String(remaining); }
          else { clearInterval(id); countdownEl.textContent='Go!'; setTimeout(()=>{ setEditorMode(false); startOverlay.classList.add('hidden'); state.countdownActive=false; state.allowCombat=true; countdownEl.textContent=''; startBtn.disabled=false; updateUIVisibility(); }, 400); }
        }, 1000);
      });

      if(openEditorBtn){ openEditorBtn.addEventListener('click',()=>{ setEditorMode(true); startOverlay.classList.add('hidden'); updateUIVisibility(); }); }

      // Editor implementation
      function setEditorMode(on){ editor.mode=!!on; if(editorControls) editorControls.style.display = editor.mode? 'block':'none'; if(editorToggle) editorToggle.textContent = editor.mode? 'Editor: ON':'Editor'; if(editor.mode){ state.paused=true; state.allowCombat=false; } if(state){ state.terrainCanvas=null; state.ownerTintCanvas=null; state._borderSegments=null; } updateUIVisibility(); }
      function populateTerrainSelect(){ if(!terrainSelect) return; terrainSelect.innerHTML=''; for(const k of Object.keys(CONFIG.terrain)){ const opt=document.createElement('option'); opt.value=k; opt.textContent=k; if(k===editor.terrain) opt.selected=true; terrainSelect.appendChild(opt); } }
      function showToolPanels(){ const tool=editor.tool; const tt=document.getElementById('toolTerrain'); const to=document.getElementById('toolOwner'); const tc=document.getElementById('toolCity'); const tu=document.getElementById('toolUnit'); if(tt) tt.style.display = (tool==='terrain')? 'block':'none'; if(to) to.style.display = (tool==='owner')? 'block':'none'; if(tc) tc.style.display = (tool==='city')? 'block':'none'; if(tu) tu.style.display = (tool==='unit')? 'block':'none'; }
      function editorPaintAtMouse(){ const cell=worldToCell(mouse.x, mouse.y); const b = editor.tool==='owner'? (editor.ownerBrush|0) : (editor.brush|0); const map=state.map; for(let dr=-b; dr<=b; dr++){ for(let dc=-b; dc<=b; dc++){ const c=cell.c+dc, r=cell.r+dr; if(c<0||r<0||c>=map.cols||r>=map.rows) continue; const idx=r*map.cols+c; const t=map.tiles[idx]; if(editor.tool==='terrain'){ t.terrain = editor.terrain; }
            else if(editor.tool==='owner'){ t.owner = editor.owner; t.control = (editor.owner==='blue'? 1:-1)*CONFIG.tileControlThreshold; }
            else if(editor.tool==='eraser'){ t.terrain = 'plains'; }
          } }
        state.terrainCanvas=null; state.ownerTintCanvas=null; state._borderSegments=null; }
      function editorPlaceOrRemove(type, button){ if(type==='city'){ if(button==='left'){ const side=editor.city.side; const isCap=editor.city.capital; const tooCloseCity=state.cities.some(ci=>Math.hypot(ci.x-mouse.x, ci.y-mouse.y)<40); if(!tooCloseCity){ state.cities.push(new City(mouse.x, mouse.y, side, isCap)); } } else if(button==='right'){ let best=-1, bestD=99999; for(let i=0;i<state.cities.length;i++){ const ci=state.cities[i]; const d=Math.hypot(ci.x-mouse.x, ci.y-mouse.y); if(d<bestD){ bestD=d; best=i; } } if(best!==-1 && bestD<40){ state.cities.splice(best,1); } } }
        if(type==='unit'){ if(button==='left'){ const side=editor.unit.side; const tank=editor.unit.tank; state.units.push(new Unit(mouse.x, mouse.y, side, tank)); } else if(button==='right'){ let best=-1, bestD=99999; for(let i=0;i<state.units.length;i++){ const u=state.units[i]; const d=Math.hypot(u.x-mouse.x, u.y-mouse.y); if(d<bestD){ bestD=d; best=i; } } if(best!==-1 && bestD<30){ state.units.splice(best,1); } } }
      }
      function editorMouseDown(which){ const tool=editor.tool; if(tool==='terrain' || tool==='owner' || tool==='eraser'){ editor.dragging=true; editorPaintAtMouse(); return; } if(tool==='city'){ editorPlaceOrRemove('city', which); return; } if(tool==='unit'){ editorPlaceOrRemove('unit', which); return; } }
      function scenarioFromState(){ const map=state.map; const tiles = map.tiles.map(t=>({ terrain:t.terrain, owner:t.owner, control:t.control })); const scen={ version:1, cols:map.cols, rows:map.rows, tiles, cities: state.cities.map(c=>({ x:c.x, y:c.y, side:c.side, isCapital: !!c.isCapital })), units: state.units.map(u=>({ x:u.x, y:u.y, side:u.side, isTank: !!u.isTank })), frontline: map.frontline }; return scen; }
      function downloadScenario(){ const scen=scenarioFromState(); const blob=new Blob([JSON.stringify(scen)], {type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='scenario.json'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0); }
      function applyScenarioObject(obj){ try{ state=createGameFromScenario(obj); editor.scenario=obj; updateUIVisibility(); } catch(err){ console.error('Failed to load scenario', err); alert('Failed to load scenario file.'); } }
      function openScenarioFileDialog(){ if(editorFileInput){ editorFileInput.value=''; editorFileInput.click(); } }
      if(editorFileInput){ editorFileInput.addEventListener('change', ()=>{ const f=editorFileInput.files&&editorFileInput.files[0]; if(!f) return; const rd=new FileReader(); rd.onload = ()=>{ try{ const obj=JSON.parse(rd.result); applyScenarioObject(obj); } catch(e){ alert('Invalid scenario file.'); } }; rd.readAsText(f); }); }
      function generateNoiseMapInPlace(){ const rng=new RNG(Math.floor(Math.random()*1e9)); if(state && state.map){ CONFIG.mapCols = state.map.cols; CONFIG.mapRows = state.map.rows; } const newMap=generateMap(rng); state.map = newMap; state.cities=[]; state.units=[]; state.terrainCanvas=null; state.ownerTintCanvas=null; state._borderSegments=null; }
      function clearMap(){ const map=state.map; for(let r=0;r<map.rows;r++){ for(let c=0;c<map.cols;c++){ const t=tileAt(map,c,r); t.terrain='plains'; t.owner = (c<map.cols/2)? 'blue':'red'; t.control= (t.owner==='blue'?1:-1)*CONFIG.tileControlThreshold; } } state.cities=[]; state.units=[]; state.terrainCanvas=null; state.ownerTintCanvas=null; state._borderSegments=null; }
      function initEditorUI(){ populateTerrainSelect(); if(terrainSelect){ terrainSelect.addEventListener('change', ()=>{ editor.terrain = terrainSelect.value; }); }
        if(brushSizeInput){ brushSizeInput.addEventListener('input', ()=>{ editor.brush = parseInt(brushSizeInput.value)||2; }); }
        if(ownerBrushInput){ ownerBrushInput.addEventListener('input', ()=>{ editor.ownerBrush = parseInt(ownerBrushInput.value)||2; }); }
        const toolRadios=document.querySelectorAll('input[name="tool"]'); toolRadios.forEach(r=> r.addEventListener('change', ()=>{ if(r.checked){ editor.tool=r.value; showToolPanels(); } }));
        const ownerRadios=document.querySelectorAll('input[name="ownerSide"]'); ownerRadios.forEach(r=> r.addEventListener('change', ()=>{ if(r.checked){ editor.owner=r.value; } }));
        const cityRadios=document.querySelectorAll('input[name="citySide"]'); cityRadios.forEach(r=> r.addEventListener('change', ()=>{ if(r.checked){ editor.city.side=r.value; } })); if(cityIsCapitalChk){ cityIsCapitalChk.addEventListener('change', ()=>{ editor.city.capital=!!cityIsCapitalChk.checked; }); }
        const unitRadios=document.querySelectorAll('input[name="unitSide"]'); unitRadios.forEach(r=> r.addEventListener('change', ()=>{ if(r.checked){ editor.unit.side=r.value; } })); if(unitIsTankChk){ unitIsTankChk.addEventListener('change', ()=>{ editor.unit.tank=!!unitIsTankChk.checked; }); }
        if(editorToggle){ editorToggle.addEventListener('click', ()=>{ setEditorMode(!(editor && editor.mode)); }); }
        if(editorSaveBtn){ editorSaveBtn.addEventListener('click', ()=> downloadScenario()); }
        if(editorLoadBtn){ editorLoadBtn.addEventListener('click', ()=> openScenarioFileDialog()); }
      if(editorPlayBtn){ editorPlayBtn.addEventListener('click', ()=>{ setEditorMode(false); startOverlay.classList.remove('hidden'); updateUIVisibility(); }); }
        if(editorGenNoiseBtn){ editorGenNoiseBtn.addEventListener('click', ()=> generateNoiseMapInPlace()); }
        if(editorClearBtn){ editorClearBtn.addEventListener('click', ()=> clearMap()); }
        showToolPanels();
      }

      // AI
      function aiUpdate(){
        if(!state.allowCombat) return;
        aiUpdateSide('red', state.difficulty, state.aggression);
        if(state.spectate) aiUpdateSide('blue', state.difficultyBlue || state.difficulty, state.aggressionBlue || state.aggression);
      }

      function aiUpdateSide(side, difficulty, aggression){
        const t=nowSec(); if(t - (state.lastPlanAt[side]||0) < CONFIG.ai.planEverySeconds) return; state.lastPlanAt[side]=t;
        const sideUnits=state.units.filter(u=>u.side===side); if(!sideUnits.length) return;
        const diff = CONFIG.difficultyPresets[difficulty||'normal'] || CONFIG.difficultyPresets.normal;
        const aggName = aggression || 'balanced';
        const agg = CONFIG.aggressionPresets[aggName] || CONFIG.aggressionPresets.balanced;
        const ownCities=state.cities.filter(c=>c.side===side);
        const enemySide = (side==='red') ? 'blue' : 'red';
        const enemyCities=state.cities.filter(c=>c.side===enemySide);

        // Apply AI speed/HP multipliers (idempotent)
        const appliedKey = side + ':' + (difficulty||state.difficulty||'normal');
        for(const u of sideUnits){
          if(u._diffApplied!==appliedKey && (side==='red' || state.spectate)){
            u.baseSpeed = (u.baseSpeedOriginal||u.baseSpeed) * diff.aiSpeedMult;
            u.baseSpeedBaseline = u.baseSpeed;
            u.maxHp = (u.maxHpOriginal||u.maxHp) * diff.aiHpMult;
            if(u.hp>u.maxHp) u.hp=u.maxHp; u._diffApplied=appliedKey;
          }
        }

        // Strict 1:1 coverage first, extras handling, and last-stand behavior
        const enemyUnits = state.units.filter(u=>u.side===enemySide);
        const ourUnits = sideUnits;
        if(ourUnits.length===0) return;
        // If no enemy units remain, push to enemy cities to finish
        if(enemyUnits.length===0){
          if(enemyCities.length){
            const caps = enemyCities.filter(c=>c.isCapital);
            for(const u of ourUnits){ const tgt=(caps[0]||enemyCities[0]); if(tgt) { const j=()=> (Math.random()-0.5)*20; u.setTarget(tgt.x+j(), tgt.y+j(), state.map); } }
          }
          return;
        }
        // Order throttling to avoid stutter and oscillation
        const ORDER_COOLDOWN = 1.4; // seconds
        const MIN_RETARGET_DIST = 26; // px
        function canOrderUnit(u){ const now=nowSec(); if(u.lockedForCombat) return false; if(u._lastOrderAt && (now - u._lastOrderAt) < ORDER_COOLDOWN) return false; return true; }
        function issueOrder(u, tx, ty, force){ const now=nowSec(); if(!force){ if(u.lockedForCombat) return false; if(u._lastOrderAt && (now - u._lastOrderAt) < ORDER_COOLDOWN) return false; if(u.target){ const dx=u.target.x-tx, dy=u.target.y-ty; if(dx*dx+dy*dy < MIN_RETARGET_DIST*MIN_RETARGET_DIST) return false; } } const j=()=> (Math.random()-0.5)*20; u.setTarget(tx+j(), ty+j(), state.map); u._lastOrderAt = now; return true; }
        function aggroMode(name){ switch(name){ case 'veryaggressive': case 'aggressive': return 'attack'; case 'slightlyaggressive': return 'lean_attack'; case 'slightlydefensive': return 'lean_defend'; case 'defensive': case 'verydefensive': return 'defend'; default: return 'balanced'; } }
        const mode = aggroMode(aggName);
        // Outnumbered: either last-stand (attack/defend) or maintain best-effort 1:1 coverage
        if(ourUnits.length < enemyUnits.length){
          if(mode==='attack'){
            if(enemyCities.length){ const caps=enemyCities.filter(c=>c.isCapital); for(const u of ourUnits){ const tgt=(caps[0]||enemyCities[0]); issueOrder(u, tgt.x, tgt.y, true); } }
            return;
          }
          if(mode==='defend'){
            if(ownCities.length){ const caps=ownCities.filter(c=>c.isCapital); for(const u of ourUnits){ const tgt=(caps[0]||ownCities[0]); issueOrder(u, tgt.x, tgt.y, true); } }
            return;
          }
          // else fall through to coverage-only
        }
        // Coverage: for each enemy, ensure at least one of ours is on them
        function enemyCovered(e){ const near=getUnitsInRadius(e.x,e.y,CONFIG.engageRadius+10); return near.some(n=>n.side===side); }
        const available=new Set(ourUnits.map((_,i)=>i));
        function popClosestAvailableTo(x,y){ let best=-1, bestScore=Infinity; for(const i of available){ const u=ourUnits[i]; if(!canOrderUnit(u)) continue; const dx=u.x-x, dy=u.y-y; const d=dx*dx+dy*dy; if(d<bestScore){ bestScore=d; best=i; } } if(best!==-1){ available.delete(best); return best; } for(const i of available){ const u=ourUnits[i]; if(!u.lockedForCombat){ available.delete(i); return i; } } const it=available.values().next(); if(!it.done){ available.delete(it.value); return it.value; } return -1; }
        for(const e of enemyUnits){ if(enemyCovered(e)) continue; const idx=popClosestAvailableTo(e.x,e.y); if(idx!==-1){ const u=ourUnits[idx]; issueOrder(u, e.x, e.y, false); } }
        // Extras: assign remaining to cities/defense/double-team depending on aggression
        const extras = Array.from(available).map(i=>ourUnits[i]);
        if(extras.length){
          let alloc={cities:0,defend:0,double:0};
          if(mode==='attack'){ alloc.cities=extras.length; }
          else if(mode==='lean_attack'){ alloc.cities=Math.round(extras.length*0.5); alloc.double=extras.length-alloc.cities; }
          else if(mode==='balanced'){ alloc.cities=Math.floor(extras.length/3); alloc.defend=Math.floor(extras.length/3); alloc.double=extras.length-alloc.cities-alloc.defend; }
          else if(mode==='lean_defend'){ alloc.defend=Math.round(extras.length*0.5); alloc.double=Math.round(extras.length*0.3); alloc.cities=extras.length-alloc.defend-alloc.double; }
          else if(mode==='defend'){ alloc.defend=extras.length; }
          let cursor=0;
          // Attack enemy cities
          for(let k=0;k<alloc.cities && cursor<extras.length;k++,cursor++){ const u=extras[cursor]; if(enemyCities.length){ const caps=enemyCities.filter(c=>c.isCapital); const tgt=(caps[0]||enemyCities[0]); issueOrder(u, tgt.x, tgt.y, false); } }
          // Defend own cities
          for(let k=0;k<alloc.defend && cursor<extras.length;k++,cursor++){ const u=extras[cursor]; if(ownCities.length){ const caps=ownCities.filter(c=>c.isCapital); const tgt=(caps[0]||ownCities[0]); issueOrder(u, tgt.x, tgt.y, false); } }
          // Double-team nearest enemies
          for(let k=0;k<alloc.double && cursor<extras.length;k++,cursor++){ const u=extras[cursor]; let best=null, bestD=Infinity; for(const e of enemyUnits){ const dx=e.x-u.x, dy=e.y-u.y; const d=dx*dx+dy*dy; if(d<bestD){ bestD=d; best=e; } } if(best){ issueOrder(u, best.x, best.y, false); } }
        }
      }

      // Combat and collisions: units stop when close to enemies
      function resolveCombatAndCollisions(dt){
        // Reset lock flags
        for(const u of state.units){ u.lockedForCombat=false; u.engaged=false; }
        rebuildSpatial();
        const engageRadius=CONFIG.engageRadius; // where damage starts
        for(const u of state.units){
          // Nearby search once per unit
          const neighbors=getUnitsInRadius(u.x,u.y,engageRadius+10);
          const enemies=neighbors.filter(n=>n.side!==u.side);
          // During countdown, collisions only (no combat lock)
          if(state.allowCombat){
            if(enemies.length){
              u.lockedForCombat=true; u.engaged=true;
            }
          }
          const friends=neighbors.filter(n=>n.side===u.side);
          // Damage taken scales with local numbers, flanking/encirclement, city distance, plus terrain effects
          if(state.allowCombat && enemies.length){
            const friendlyCount=Math.max(1, friends.length);
            const enemyCount=Math.max(1, enemies.length);
            // Estimate directional flanks by sampling enemy bearings
            let left=0,right=0,up=0,down=0; for(const e of enemies){ const dx=e.x-u.x, dy=e.y-u.y; if(Math.abs(dx)>Math.abs(dy)){ if(dx<0) left++; else right++; } else { if(dy<0) up++; else down++; } }
            const flankDirs = [left>0,right>0,up>0,down>0].filter(Boolean).length; // 1..4
            const flankMultiplier = 1 + (flankDirs-1)*0.35; // +35% per extra side
            const outnumberedMultiplier = enemyCount / friendlyCount;
            const diff = CONFIG.difficultyPresets[state.difficulty||'normal'] || CONFIG.difficultyPresets.normal;
            const typeMod = (u.isTank?0.8:1);
            // Terrain damage taken modifier
            const cell=worldToCell(u.x,u.y); const tt=tileAt(state.map,cell.c,cell.r); const terrMod = tt ? (CONFIG.terrain[tt.terrain].damageTakenMultiplier || 1) : 1;
            // Distance from nearest friendly city reduces incoming damage (logistic falloff)
            function nearestFriendlyCityIncomingDamageMultiplier(unit){
              let best=Infinity; for(const ci of state.cities){ if(ci.side!==unit.side) continue; const d=Math.hypot(ci.x-unit.x, ci.y-unit.y); if(d<best) best=d; }
              const fall=CONFIG.cityDamageFalloffPx; const min=CONFIG.cityDamageMinMultiplier; if(!isFinite(best)) return min; const t=best/fall; const k=1/(1+Math.exp(4*(t-1))); // sigmoid centered at falloff distance
              // Near city (k≈1) => multiplier≈min (less incoming damage). Far (k≈0) => multiplier≈1.
              return clamp(min + (1-min)*(1-k), min, 1);
            }
            const cityMult = nearestFriendlyCityIncomingDamageMultiplier(u);
            const aiMult = (u.side==='red') ? diff.aiDamageMult : 1;
            const totalDps=enemies.reduce((s,e)=>s+e.dps,0) * typeMod * outnumberedMultiplier * flankMultiplier * terrMod * cityMult * aiMult;
            u.hp -= totalDps*dt*0.15;
            // Dynamic frontline push/pull: winners push forward, losers fall back proportionally to advantage
            const advantage = (friendlyCount - enemyCount) / Math.max(friendlyCount, enemyCount);
            if(Math.abs(advantage) > 0.05){
              const dirX = (u.target? u.target.x : u.x) - u.x;
              const dirY = (u.target? u.target.y : u.y) - u.y;
              const len = Math.hypot(dirX,dirY) || 1;
              const nx = dirX/len, ny = dirY/len;
              const push = CONFIG.combatPush.maxPxPerSec * dt * Math.max(0, advantage);
              const pull = CONFIG.combatPush.maxPxPerSec * dt * Math.max(0, -advantage);
              if(advantage>0){ u.x += nx*push; u.y += ny*push; }
              else { u.x -= nx*pull; u.y -= ny*pull; }
            }
          }
          // Physical collision with minimum navigable gap rule; softer friendly collision
          let hasFriendlyOverlap=false;
          for(const v of neighbors){ if(v===u) continue; const dx=u.x-v.x, dy=u.y-v.y; const d=Math.hypot(dx,dy); const minGap=(u.radius+v.radius)*CONFIG.minGapFactor; const minDist=u.radius+v.radius;
            if(v.side!==u.side){ if(d>0 && d<minDist){ const overlap=minDist-d+0.5; const nx=(dx===0&&dy===0)? (Math.random()*2-1) : dx/d; const ny=(dx===0&&dy===0)? (Math.random()*2-1) : dy/d; const push=overlap*0.6; u.x+=nx*push; u.y+=ny*push; v.x-=nx*push; v.y-=ny*push; } }
            else { if(d>0 && d<minDist){ hasFriendlyOverlap=true; } }
            // When navigating between two friendlies, block if corridor narrower than minGap
            // Approximate by checking another neighbor forming a corridor
          if(v.side!==u.side && d>0 && d < minGap){
              // Treat as blocking by marking both as locked for combat, preventing squeeze-through
             u.lockedForCombat = true; v.lockedForCombat = true;
            }
          }
          // restore/reset speed depending on friendly overlap state (preserve difficulty-adjusted baseline)
          if(hasFriendlyOverlap){ u.baseSpeed = Math.max(10, (u.baseSpeedBaseline||u.baseSpeed)*0.65); }
          else { u.baseSpeed = (u.baseSpeedBaseline||u.baseSpeed); }
          // Edge handling: gently steer units back inside instead of hard clamping
          const margin = Math.max(u.radius+2, 6);
          const steer = 0.5;
          if(u.x < margin){ u.x += steer; if(u.target) u.target.x = Math.max(u.target.x, margin+10); }
          if(u.x > canvas.width - margin){ u.x -= steer; if(u.target) u.target.x = Math.min(u.target.x, canvas.width - margin - 10); }
          if(u.y < margin){ u.y += steer; if(u.target) u.target.y = Math.max(u.target.y, margin+10); }
          if(u.y > canvas.height - margin){ u.y -= steer; if(u.target) u.target.y = Math.min(u.target.y, canvas.height - margin - 10); }
        }
        // Cleanup dead
        state.units = state.units.filter(u=>u.hp>0);
      }

      function ensureTerrainCanvas(){
        if(!state) return;
        const w = canvas.width, h = canvas.height;
        if(state.terrainCanvas && state.terrainCanvas.width===w && state.terrainCanvas.height===h) return;
        const off = document.createElement('canvas'); off.width=w; off.height=h; const octx = off.getContext('2d');
        const map = state.map;
        for(let r=0;r<map.rows;r++){
          for(let c=0;c<map.cols;c++){
            const t=tileAt(map,c,r); octx.fillStyle=CONFIG.terrain[t.terrain].color; octx.fillRect(c*TILE_W,r*TILE_H,TILE_W,TILE_H);
          }
        }
        state.terrainCanvas = off;
      }
      function ensureOwnerTintCanvas(){
        if(!state) return;
        const w = canvas.width, h = canvas.height;
        const now = nowSec();
        const needNew = !state.ownerTintCanvas || state.ownerTintCanvas.width!==w || state.ownerTintCanvas.height!==h || !state._ownerTintCacheAtSec || (now - state._ownerTintCacheAtSec) > 0.1;
        if(!needNew) return;
        const off = state.ownerTintCanvas || document.createElement('canvas'); off.width=w; off.height=h; const octx = off.getContext('2d');
        octx.clearRect(0,0,w,h);
        const map = state.map;
        for(let r=0;r<map.rows;r++){
          for(let c=0;c<map.cols;c++){
            const t=tileAt(map,c,r);
            octx.fillStyle = t.owner==='blue' ? 'rgba(60,150,255,0.10)' : 'rgba(255,100,100,0.10)';
            octx.fillRect(c*TILE_W,r*TILE_H,TILE_W,TILE_H);
          }
        }
        state.ownerTintCanvas = off;
        state._ownerTintCacheAtSec = now;
      }
      function drawMap(map){
        ensureTerrainCanvas();
        if(state && state.terrainCanvas) ctx.drawImage(state.terrainCanvas, 0, 0);
        ensureOwnerTintCanvas();
        if(state && state.ownerTintCanvas) ctx.drawImage(state.ownerTintCanvas, 0, 0);
        drawSmoothBorders(map);
      }

      // Marching squares based smooth border drawing
      function drawSmoothBorders(map){
        const cols=map.cols, rows=map.rows;
        const now = nowSec();
        let segments = state && state._borderSegments;
        if(!segments || !state._borderCacheAtSec || (now - state._borderCacheAtSec) > 0.1){
          function val(c,r){ const t=tileAt(map,c,r); if(!t) return 0; return t.control || (t.owner==='blue'?1:-1); }
          function lerp(a,b){ if(a===b) return 0.5; const t = (0 - a)/(b - a); return isFinite(t)? t : 0.5; }
          segments=[];
          for(let r=0;r<rows-1;r++){
            for(let c=0;c<cols-1;c++){
              const v00=val(c,r), v10=val(c+1,r), v11=val(c+1,r+1), v01=val(c,r+1);
              const signDiff=(a,b)=> (a>0)!==(b>0);
              const points=[]; // in order: top,right,bottom,left
              if(signDiff(v00,v10)){
                const t=lerp(v00,v10); const x=(c+0.5 + t)*TILE_W, y=(r+0.5)*TILE_H; points.push({x,y,edge:'top'});
              }
              if(signDiff(v10,v11)){
                const t=lerp(v10,v11); const x=(c+1+0.5)*TILE_W, y=(r+0.5 + t)*TILE_H; points.push({x,y,edge:'right'});
              }
              if(signDiff(v11,v01)){
                const t=lerp(v11,v01); const x=(c+0.5 + t)*TILE_W, y=(r+1+0.5)*TILE_H; points.push({x,y,edge:'bottom'});
              }
              if(signDiff(v01,v00)){
                const t=lerp(v01,v00); const x=(c+0.5)*TILE_W, y=(r+0.5 + t)*TILE_H; points.push({x,y,edge:'left'});
              }
              if(points.length===2){ segments.push([points[0], points[1]]); }
              else if(points.length===4){
                const center=(v00+v10+v11+v01)/4;
                if(center>0){ segments.push([points[0], points[3]]); segments.push([points[1], points[2]]); }
                else { segments.push([points[0], points[1]]); segments.push([points[2], points[3]]); }
              }
            }
          }
          if(state){ state._borderSegments = segments; state._borderCacheAtSec = now; }
        }
        if(!segments || !segments.length) return;
        ctx.save();
        ctx.strokeStyle=CONFIG.borders.color;
        ctx.lineWidth=CONFIG.borders.width;
        ctx.lineJoin='round'; ctx.lineCap='round';
        ctx.beginPath();
        for(const seg of segments){ ctx.moveTo(seg[0].x, seg[0].y); ctx.lineTo(seg[1].x, seg[1].y); }
        ctx.stroke();
        ctx.restore();
      }

      // Flood-fill encirclement conversion: converts isolated enemy regions with no enemies inside
      let lastEncirclementCheck = 0;
      function checkEncirclements(){
        const t=nowSec(); if(t - lastEncirclementCheck < CONFIG.encirclementCheckSeconds) return; lastEncirclementCheck = t;
        const map = state.map; const cols=map.cols, rows=map.rows; const visited=new Uint8Array(cols*rows);
        function idx(c,r){return r*cols+c;}
        function regionAt(c0,r0){
          const start=tileAt(map,c0,r0); if(!start) return null; const targetOwner=start.owner; const q=[[c0,r0]]; const cells=[]; let touchesEdge=false; let hasEnemyUnit=false;
          visited[idx(c0,r0)]=1;
          while(q.length){ const [c,r]=q.pop(); const t=tileAt(map,c,r); cells.push([c,r]); if(c===0||r===0||c===cols-1||r===rows-1) touchesEdge=true;
            // detect units of opposite side inside
            const center=cellCenter(c,r); const near=getUnitsInRadius(center.x, center.y, TILE_W*0.8);
            if(near.some(u=> (t.owner==='blue'? u.side==='blue': u.side==='red'))) hasEnemyUnit=true;
            const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; for(const [dc,dr] of dirs){ const nc=c+dc, nr=r+dr; if(nc<0||nr<0||nc>=cols||nr>=rows) continue; const nt=tileAt(map,nc,nr); if(!nt||visited[idx(nc,nr)]) continue; if(nt.owner===targetOwner){ visited[idx(nc,nr)]=1; q.push([nc,nr]); }
            }
          }
          return { cells, touchesEdge, hasEnemyUnit, owner: targetOwner };
        }
        for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
          const i=idx(c,r); if(visited[i]) continue; const t0=tileAt(map,c,r); if(!t0) continue; const reg=regionAt(c,r); if(!reg) continue;
          // If region is enemy-owned and enclosed by our ownership boundary, convert when no enemy units inside
          const our='blue', theirs='red';
          for(const perspective of [['blue','red'],['red','blue']]){
            const ours=perspective[0], theirs=perspective[1];
            if(reg.owner!==theirs) continue; // not enemy region
            // touching the edge means it's connected to the rest of territory
            if(reg.touchesEdge) continue;
            if(reg.hasEnemyUnit) continue; // enemy present blocks conversion
            // Convert region to our side
            for(const [c2,r2] of reg.cells){ const tt=tileAt(map,c2,r2); tt.owner=ours; tt.control=(ours==='blue'?1:-1)*CONFIG.tileControlThreshold; }
          }
        }
      }

      let lastTime=performance.now();
      function currentTimeScale(){ const key=(state && state.speedPreset) || 'default'; const preset=CONFIG.speedPresets[key] ?? CONFIG.defaultTimeScale; return preset; }
      function update(){ const now=performance.now(); let dt=(now-lastTime)/1000; lastTime=now; dt=Math.min(dt,0.05); dt*=currentTimeScale(); if(!state.paused && !state.winner){
          if(state.allowCombat){
            // Resolve combat/collisions first so units stop before moving
            resolveCombatAndCollisions(dt);
            // Cities
            for(const city of state.cities) city.update(dt,state.map);
            // Units move/capture
            for(const u of state.units) u.update(dt,state.map);
            // AI
            aiUpdate();
            // Encirclement auto-conversion
            checkEncirclements();
          }
          // Victory check
          const blueCap=state.cities.find(c=>c.isCapital && c.side==='blue');
          const redCap=state.cities.find(c=>c.isCapital && c.side==='red');
          // New win/lose logic with grace period and majority city rule
          if(!state.originalCityCount){
            state.originalCityCount = {
              blue: state.cities.filter(c=>c.side==='blue').length,
              red: state.cities.filter(c=>c.side==='red').length,
            };
          }
          if(!state.grace){ state.grace = { blue: null, red: null }; }
          function checkSide(side){
            const capAlive = state.cities.some(c=>c.isCapital && c.side===side);
            const currentOwned = state.cities.filter(c=>c.side===side).length;
            const orig = state.originalCityCount[side]||1;
            const need = Math.ceil(orig*0.5);
            if(capAlive) { state.grace[side]=null; return null; }
            if(currentOwned >= need){ state.grace[side]=null; return null; }
            if(!state.grace[side]) state.grace[side] = { start: nowSec() };
            const elapsed = nowSec() - state.grace[side].start;
            if(elapsed > 30) return 'lose';
            return null;
          }
          const blueState = checkSide('blue');
          const redState = checkSide('red');
          if(blueState==='lose' && !state.winner) state.winner='red';
          if(redState==='lose' && !state.winner) state.winner='blue';
        } }

      function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawMap(state.map); for(const c of state.cities) c.draw(ctx); 
        // Draw paths for selected units (smoothed with quadratic curve)
        const selectedUnits = state.units.filter(u=>u.selected && u.path && u.path.length>u.pathIndex);
        if(selectedUnits.length){
          ctx.save();
          ctx.lineWidth = 2.5;
          ctx.setLineDash([]);
          ctx.strokeStyle = 'rgba(255,255,255,0.85)';
          ctx.shadowColor = 'rgba(0,0,0,0.5)';
          ctx.shadowBlur = 2;
          for(const u of selectedUnits){
            const pts=[]; pts.push({x:u.x,y:u.y}); for(let i=u.pathIndex; i<u.path.length; i++){ const n=u.path[i]; const p=cellCenter(n.c,n.r); pts.push(p); }
            if(pts.length>=2){
              ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
              for(let i=1;i<pts.length-1;i++){
                const midX=(pts[i].x+pts[i+1].x)/2, midY=(pts[i].y+pts[i+1].y)/2; ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
              }
              ctx.lineTo(pts[pts.length-1].x, pts[pts.length-1].y);
              ctx.stroke();
              // Arrowhead at end
              const a=pts[pts.length-2], b=pts[pts.length-1]; const ang=Math.atan2(b.y-a.y,b.x-a.x); const len=12;
              ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - Math.cos(ang-0.5)*len, b.y - Math.sin(ang-0.5)*len); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - Math.cos(ang+0.5)*len, b.y - Math.sin(ang+0.5)*len); ctx.stroke();
            }
          }
          ctx.restore();
        }
        // Show temporary right-drag stroke when building a path
        if(rdrag && rdrag.active && rdrag.points.length>1){
          ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=2; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(rdrag.points[0].x, rdrag.points[0].y); for(let i=1;i<rdrag.points.length;i++){ ctx.lineTo(rdrag.points[i].x, rdrag.points[i].y); } ctx.stroke(); ctx.restore();
        }
        for(const u of state.units) u.draw(ctx); if(drag){ const x=Math.min(drag.x0,drag.x1), y=Math.min(drag.y0,drag.y1); const w=Math.abs(drag.x1-drag.x0), h=Math.abs(drag.y1-drag.y0); ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.fillRect(x,y,w,h); ctx.strokeStyle=CONFIG.selectionColor; ctx.lineWidth=1.2; ctx.strokeRect(x,y,w,h); }
        // Editor overlay
        if(editor && editor.mode){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=1; const b=(editor.tool==='owner'? editor.ownerBrush: editor.brush)||2; const cell=worldToCell(mouse.x, mouse.y); const x=(cell.c+0.5)*TILE_W, y=(cell.r+0.5)*TILE_H; const rad=Math.max(TILE_W, TILE_H)*b; ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
        const bu=state.units.filter(u=>u.side==='blue').length; const ru=state.units.filter(u=>u.side==='red').length; const time=Math.floor(nowSec()-state.startedAt); hudText.textContent=`Time ${time}s | Blue units ${bu} | Red units ${ru}`; if(state.winner){ overlay.classList.add('show'); const msg=state.winner==='blue'?'Victory':'Defeat'; resultTitle.textContent=msg; resultSubtitle.textContent=state.winner==='blue'?'You captured the enemy capital.':'Your capital was captured.'; }
        // Editor HUD hint
        if(editor && editor.mode){ hudText.textContent += ' | EDITOR MODE'; }
      }

      function loop(){ update(); draw(); requestAnimationFrame(loop); }

      resizeCanvasToWindow(); state=createGame(); initEditorUI(); updateUIVisibility(); // Wait for player to press Start (no spawns before start due to paused state)
      // keep drawing idle scene
      loop();
    </script>
  </body>
</html>


